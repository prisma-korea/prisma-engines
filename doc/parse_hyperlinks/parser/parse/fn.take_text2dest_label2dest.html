<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Consumes the input until it finds a Markdown, RestructuredText, Asciidoc or HTML formatted inline link (`Text2Dest`) or link reference definition (`Label2Dest`)."><meta name="keywords" content="rust, rustlang, rust-lang, take_text2dest_label2dest"><title>take_text2dest_label2dest in parse_hyperlinks::parser::parse - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../parse_hyperlinks/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../parse_hyperlinks/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In parse_hyperlinks::parser::parse</a></h2><div id="sidebar-vars" data-name="take_text2dest_label2dest" data-ty="fn" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../parse_hyperlinks/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Function <a href="../../index.html">parse_hyperlinks</a>::<wbr><a href="../index.html">parser</a>::<wbr><a href="index.html">parse</a>::<wbr><a class="fn" href="#">take_text2dest_label2dest</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/parse_hyperlinks/parser/parse.rs.html#102-117">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust fn"><code>pub fn take_text2dest_label2dest(<br>&nbsp;&nbsp;&nbsp;&nbsp;i: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a><br>) -&gt; <a class="type" href="../../../nom/internal/type.IResult.html" title="type nom::internal::IResult">IResult</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a>, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">(</a><a class="enum" href="https://doc.rust-lang.org/1.61.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a>&gt;, <a class="enum" href="https://doc.rust-lang.org/1.61.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a>&gt;, <a class="enum" href="https://doc.rust-lang.org/1.61.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'_, <a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.str.html">str</a>&gt;<a class="primitive" href="https://doc.rust-lang.org/1.61.0/std/primitive.tuple.html">)</a>&gt;</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Consumes the input until it finds a Markdown, RestructuredText, Asciidoc or
HTML formatted <em>inline link</em> (<code>Text2Dest</code>) or <em>link reference definition</em>
(<code>Label2Dest</code>).</p>
<p>Returns <code>Ok((remaining_input, (link_text_or_label, link_destination, link_title)))</code>. The parser recognizes only stand alone <em>inline links</em> and
<em>link reference definitions</em>, but no <em>reference links</em>.</p>
<h2 id="limitations"><a href="#limitations">Limitations:</a></h2>
<p>Link reference labels are never resolved into link text. This limitation only
concerns this parser. Others are not affected.</p>
<p>Very often this limitation has no effect at all. This is the case, when the
<em>link text</em> and the <em>link label</em> are identical:</p>
<div class="example-wrap"><pre class="language-md"><code>abc [link text/label] abc

[link text/label]: /url &quot;title&quot;</code></pre></div>
<p>But in general, the <em>link text</em> and the <em>link label</em> can be different:</p>
<div class="example-wrap"><pre class="language-md"><code>abc [link text][link label] abc

[link label]: /url &quot;title&quot;</code></pre></div>
<p>When a link reference definition is found, the parser outputs it’s link label
instead of the link text, which is strictly speaking only correct when both
are identical. Note, the same applies to RestructuredText’s link reference
definitions too.</p>
<p>Another limitation is that ReStructuredText’s anonymous links are not supported.</p>
<h2 id="basic-usage"><a href="#basic-usage">Basic usage</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">parse_hyperlinks::parser::parse::take_text2dest_label2dest</span>;
<span class="kw">use</span> <span class="ident">std::borrow::Cow</span>;

<span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="string">r#&quot;[a]: b &#39;c&#39;
           .. _d: e
           ---[f](g &#39;h&#39;)---`i &lt;j&gt;`_---
           ---&lt;a href=&quot;l&quot; title=&quot;m&quot;&gt;k&lt;/a&gt;&quot;#</span>;

<span class="kw">let</span> (<span class="ident">i</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">take_text2dest_label2dest</span>(<span class="ident">i</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, (<span class="ident">Cow::from</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;b&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;c&quot;</span>)));
<span class="kw">let</span> (<span class="ident">i</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">take_text2dest_label2dest</span>(<span class="ident">i</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, (<span class="ident">Cow::from</span>(<span class="string">&quot;d&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;e&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;&quot;</span>)));
<span class="kw">let</span> (<span class="ident">i</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">take_text2dest_label2dest</span>(<span class="ident">i</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, (<span class="ident">Cow::from</span>(<span class="string">&quot;f&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;g&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;h&quot;</span>)));
<span class="kw">let</span> (<span class="ident">i</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">take_text2dest_label2dest</span>(<span class="ident">i</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, (<span class="ident">Cow::from</span>(<span class="string">&quot;i&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;j&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;&quot;</span>)));
<span class="kw">let</span> (<span class="ident">i</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="ident">take_text2dest_label2dest</span>(<span class="ident">i</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">r</span>, (<span class="ident">Cow::from</span>(<span class="string">&quot;k&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;l&quot;</span>), <span class="ident">Cow::from</span>(<span class="string">&quot;m&quot;</span>)));</code></pre></div>
<p>The parser might silently consume some additional bytes after the actual finding: This happens,
when directly after a finding a <code>md_link_ref</code> or <code>rst_link_ref</code> appears. These must be ignored,
as they are only allowed at the beginning of a line. The skip has to happen at this moment, as
the next parser does not know if the first byte it gets, is it at the beginning of a line or
not.</p>
<p>Technically, this parser is a wrapper around <code>take_link()</code>, that erases the
link type information and ignores all <em>reference links</em>. In case the input
text contains <em>link reference definitions</em>, this function is be faster than
the <code>parse_hyperlinks::iterator::Hyperlink</code> iterator.</p>
<p>Note: This function is depreciated and will be removed in some later release.
Use <code>take_link()</code> instead.</p>
</div></details></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="parse_hyperlinks" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>