<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Frunk: generic functional programming toolbelt for Rust"><meta name="keywords" content="rust, rustlang, rust-lang, frunk"><title>frunk - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../frunk/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../frunk/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate frunk</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#derives">Derive Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">frunk</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/frunk/lib.rs.html#1-309">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Frunk: generic functional programming toolbelt for Rust</p>
<p>Aims to be a collection of functional programming abstractions implemented in Rust
in effective, useful, and idiomatic ways. Examples of things that are included in rust are:</p>
<ol>
<li>HLists (heterogeneously-typed lists)</li>
<li>LabelledGeneric, and Generic</li>
<li>Coproduct</li>
<li>Validated (accumulator for Result)</li>
<li>Semigroup</li>
<li>Monoid</li>
</ol>
<p>Here is a small taste of what Frunk has to offer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>frunk::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>frunk::{<span class="self">self</span>, monoid, Semigroup, Generic};

<span class="comment">// Combining Monoids
</span><span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="number">3</span>)];
<span class="macro">assert_eq!</span>(monoid::combine_all(<span class="kw-2">&amp;</span>v), <span class="prelude-val">Some</span>(<span class="number">4</span>));

<span class="comment">// HLists
</span><span class="kw">let </span>h = <span class="macro">hlist!</span>[<span class="number">1</span>, <span class="string">&quot;hi&quot;</span>];
<span class="macro">assert_eq!</span>(h.len(), <span class="number">2</span>);
<span class="kw">let </span><span class="macro">hlist_pat!</span>(a, b) = h;
<span class="macro">assert_eq!</span>(a, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(b, <span class="string">&quot;hi&quot;</span>);

<span class="kw">let </span>h1 = <span class="macro">hlist!</span>[<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="number">3.3</span>, <span class="number">53i64</span>, <span class="string">&quot;hello&quot;</span>.to_owned()];
<span class="kw">let </span>h2 = <span class="macro">hlist!</span>[<span class="prelude-val">Some</span>(<span class="number">2</span>), <span class="number">1.2</span>, <span class="number">1i64</span>, <span class="string">&quot; world&quot;</span>.to_owned()];
<span class="kw">let </span>h3 = <span class="macro">hlist!</span>[<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="number">4.5</span>, <span class="number">54</span>, <span class="string">&quot;hello world&quot;</span>.to_owned()];
<span class="macro">assert_eq!</span>(h1.combine(<span class="kw-2">&amp;</span>h2), h3);

<span class="comment">// Generic and LabelledGeneric-based programming
// Allows Structs to play well easily with HLists

</span><span class="attr">#[derive(Generic, LabelledGeneric)]
</span><span class="kw">struct </span>ApiUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    FirstName: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    LastName: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    Age: usize,
}

<span class="attr">#[derive(Generic, LabelledGeneric)]
</span><span class="kw">struct </span>NewUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    first_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    last_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    age: usize,
}

<span class="attr">#[derive(LabelledGeneric)]
</span><span class="kw">struct </span>SavedUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    first_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    last_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    age: usize,
}

<span class="comment">// Instantiate a struct from an HList. Note that you can go the other way too.
</span><span class="kw">let </span>a_user: ApiUser = frunk::from_generic(<span class="macro">hlist!</span>[<span class="string">&quot;Joe&quot;</span>, <span class="string">&quot;Blow&quot;</span>, <span class="number">30</span>]);

<span class="comment">// Convert using Generic
</span><span class="kw">let </span>n_user: NewUser = Generic::convert_from(a_user); <span class="comment">// done

// Convert using LabelledGeneric
//
// This will fail if the fields of the types converted to and from do not
// have the same names or do not line up properly :)
//
// Also note that we&#39;re using a helper method to avoid having to use universal
// function call syntax
</span><span class="kw">let </span>s_user: SavedUser = frunk::labelled_convert_from(n_user);

<span class="macro">assert_eq!</span>(s_user.first_name, <span class="string">&quot;Joe&quot;</span>);
<span class="macro">assert_eq!</span>(s_user.last_name, <span class="string">&quot;Blow&quot;</span>);
<span class="macro">assert_eq!</span>(s_user.age, <span class="number">30</span>);

<span class="comment">// Uh-oh ! last_name and first_name have been flipped!
</span><span class="attr">#[derive(LabelledGeneric)]
</span><span class="kw">struct </span>DeletedUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    last_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    first_name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    age: usize,
}
<span class="comment">// let d_user = &lt;DeletedUser as LabelledGeneric&gt;::convert_from(s_user); &lt;-- this would fail at compile time :)

// This will, however, work, because we make use of the Sculptor type-class
// to type-safely reshape the representations to align/match each other.
</span><span class="kw">let </span>d_user: DeletedUser = frunk::transform_from(s_user);
<span class="macro">assert_eq!</span>(d_user.first_name, <span class="string">&quot;Joe&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bmacro_use%5D%20extern%20crate%20frunk%3B%0A%23%5Bmacro_use%5D%20extern%20crate%20frunk_core%3B%0Afn%20main()%20%7B%0Ause%20frunk%3A%3Aprelude%3A%3A*%3B%0Ause%20frunk%3A%3A%7Bself%2C%20monoid%2C%20Semigroup%2C%20Generic%7D%3B%0A%0A%2F%2F%20Combining%20Monoids%0Alet%20v%20%3D%20vec!%5BSome(1)%2C%20Some(3)%5D%3B%0Aassert_eq!(monoid%3A%3Acombine_all(%26v)%2C%20Some(4))%3B%0A%0A%2F%2F%20HLists%0Alet%20h%20%3D%20hlist!%5B1%2C%20%22hi%22%5D%3B%0Aassert_eq!(h.len()%2C%202)%3B%0Alet%20hlist_pat!(a%2C%20b)%20%3D%20h%3B%0Aassert_eq!(a%2C%201)%3B%0Aassert_eq!(b%2C%20%22hi%22)%3B%0A%0Alet%20h1%20%3D%20hlist!%5BSome(1)%2C%203.3%2C%2053i64%2C%20%22hello%22.to_owned()%5D%3B%0Alet%20h2%20%3D%20hlist!%5BSome(2)%2C%201.2%2C%201i64%2C%20%22%20world%22.to_owned()%5D%3B%0Alet%20h3%20%3D%20hlist!%5BSome(3)%2C%204.5%2C%2054%2C%20%22hello%20world%22.to_owned()%5D%3B%0Aassert_eq!(h1.combine(%26h2)%2C%20h3)%3B%0A%0A%2F%2F%20Generic%20and%20LabelledGeneric-based%20programming%0A%2F%2F%20Allows%20Structs%20to%20play%20well%20easily%20with%20HLists%0A%0A%23%5Bderive(Generic%2C%20LabelledGeneric)%5D%0Astruct%20ApiUser%3C'a%3E%20%7B%0A%20%20%20%20FirstName%3A%20%26'a%20str%2C%0A%20%20%20%20LastName%3A%20%26'a%20str%2C%0A%20%20%20%20Age%3A%20usize%2C%0A%7D%0A%0A%23%5Bderive(Generic%2C%20LabelledGeneric)%5D%0Astruct%20NewUser%3C'a%3E%20%7B%0A%20%20%20%20first_name%3A%20%26'a%20str%2C%0A%20%20%20%20last_name%3A%20%26'a%20str%2C%0A%20%20%20%20age%3A%20usize%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric)%5D%0Astruct%20SavedUser%3C'a%3E%20%7B%0A%20%20%20%20first_name%3A%20%26'a%20str%2C%0A%20%20%20%20last_name%3A%20%26'a%20str%2C%0A%20%20%20%20age%3A%20usize%2C%0A%7D%0A%0A%2F%2F%20Instantiate%20a%20struct%20from%20an%20HList.%20Note%20that%20you%20can%20go%20the%20other%20way%20too.%0Alet%20a_user%3A%20ApiUser%20%3D%20frunk%3A%3Afrom_generic(hlist!%5B%22Joe%22%2C%20%22Blow%22%2C%2030%5D)%3B%0A%0A%2F%2F%20Convert%20using%20Generic%0Alet%20n_user%3A%20NewUser%20%3D%20Generic%3A%3Aconvert_from(a_user)%3B%20%2F%2F%20done%0A%0A%2F%2F%20Convert%20using%20LabelledGeneric%0A%2F%2F%0A%2F%2F%20This%20will%20fail%20if%20the%20fields%20of%20the%20types%20converted%20to%20and%20from%20do%20not%0A%2F%2F%20have%20the%20same%20names%20or%20do%20not%20line%20up%20properly%20%3A)%0A%2F%2F%0A%2F%2F%20Also%20note%20that%20we're%20using%20a%20helper%20method%20to%20avoid%20having%20to%20use%20universal%0A%2F%2F%20function%20call%20syntax%0Alet%20s_user%3A%20SavedUser%20%3D%20frunk%3A%3Alabelled_convert_from(n_user)%3B%0A%0Aassert_eq!(s_user.first_name%2C%20%22Joe%22)%3B%0Aassert_eq!(s_user.last_name%2C%20%22Blow%22)%3B%0Aassert_eq!(s_user.age%2C%2030)%3B%0A%0A%2F%2F%20Uh-oh%20!%20last_name%20and%20first_name%20have%20been%20flipped!%0A%23%5Bderive(LabelledGeneric)%5D%0Astruct%20DeletedUser%3C'a%3E%20%7B%0A%20%20%20%20last_name%3A%20%26'a%20str%2C%0A%20%20%20%20first_name%3A%20%26'a%20str%2C%0A%20%20%20%20age%3A%20usize%2C%0A%7D%0A%2F%2F%20let%20d_user%20%3D%20%3CDeletedUser%20as%20LabelledGeneric%3E%3A%3Aconvert_from(s_user)%3B%20%3C--%20this%20would%20fail%20at%20compile%20time%20%3A)%0A%0A%2F%2F%20This%20will%2C%20however%2C%20work%2C%20because%20we%20make%20use%20of%20the%20Sculptor%20type-class%0A%2F%2F%20to%20type-safely%20reshape%20the%20representations%20to%20align%2Fmatch%20each%20other.%0Alet%20d_user%3A%20DeletedUser%20%3D%20frunk%3A%3Atransform_from(s_user)%3B%0Aassert_eq!(d_user.first_name%2C%20%22Joe%22)%3B%0A%7D&amp;edition=2015">Run</a></div>
<h6 id="transmogrifying"><a href="#transmogrifying">Transmogrifying</a></h6>
<p>Sometimes you need might have one data type that is “similar in shape” to another data type, but it
is similar <em>recursively</em> (e.g. it has fields that are structs that have fields that are a superset of
the fields in the target type, so they are transformable recursively).  <code>.transform_from</code> can’t
help you there because it doesn’t deal with recursion, but the <code>Transmogrifier</code> can help if both
are <code>LabelledGeneric</code> by <code>transmogrify()</code>ing from one to the other.</p>
<p>What is “transmogrifying”? In this context, it means to recursively transform some data of type A
into data of type B, in a typesafe way, as long as A and B are “similarly-shaped”.  In other words,
as long as B’s fields and their subfields are subsets of A’s fields and their respective subfields,
then A can be turned into B.</p>
<p>As usual, the goal with Frunk is to do this:</p>
<ul>
<li>Using stable (so no specialisation, which would have been helpful, methinks)</li>
<li>Typesafe</li>
<li>No usage of <code>unsafe</code></li>
</ul>
<p>Here is an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>frunk::labelled::Transmogrifier;

<span class="attr">#[derive(LabelledGeneric)]
</span><span class="kw">struct </span>InternalPhoneNumber {
    emergency: <span class="prelude-ty">Option</span>&lt;usize&gt;,
    main: usize,
    secondary: <span class="prelude-ty">Option</span>&lt;usize&gt;,
}

<span class="attr">#[derive(LabelledGeneric)]
</span><span class="kw">struct </span>InternalAddress&lt;<span class="lifetime">&#39;a</span>&gt; {
    is_whitelisted: bool,
    name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    phone: InternalPhoneNumber,
}

<span class="attr">#[derive(LabelledGeneric)]
</span><span class="kw">struct </span>InternalUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    age: usize,
    address: InternalAddress&lt;<span class="lifetime">&#39;a</span>&gt;,
    is_banned: bool,
}

<span class="attr">#[derive(LabelledGeneric, PartialEq, Debug)]
</span><span class="kw">struct </span>ExternalPhoneNumber {
    main: usize,
}

<span class="attr">#[derive(LabelledGeneric, PartialEq, Debug)]
</span><span class="kw">struct </span>ExternalAddress&lt;<span class="lifetime">&#39;a</span>&gt; {
    name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    phone: ExternalPhoneNumber,
}

<span class="attr">#[derive(LabelledGeneric, PartialEq, Debug)]
</span><span class="kw">struct </span>ExternalUser&lt;<span class="lifetime">&#39;a</span>&gt; {
    age: usize,
    address: ExternalAddress&lt;<span class="lifetime">&#39;a</span>&gt;,
    name: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
}

<span class="kw">let </span>internal_user = InternalUser {
    name: <span class="string">&quot;John&quot;</span>,
    age: <span class="number">10</span>,
    address: InternalAddress {
        is_whitelisted: <span class="bool-val">true</span>,
        name: <span class="string">&quot;somewhere out there&quot;</span>,
        phone: InternalPhoneNumber {
            main: <span class="number">1234</span>,
            secondary: <span class="prelude-val">None</span>,
            emergency: <span class="prelude-val">Some</span>(<span class="number">5678</span>),
        },
    },
    is_banned: <span class="bool-val">true</span>,
};

<span class="doccomment">/// Boilerplate-free conversion of a top-level InternalUser into an
/// ExternalUser, taking care of subfield conversions as well.
</span><span class="kw">let </span>external_user: ExternalUser = internal_user.transmogrify();

<span class="kw">let </span>expected_external_user = ExternalUser {
    name: <span class="string">&quot;John&quot;</span>,
    age: <span class="number">10</span>,
    address: ExternalAddress {
        name: <span class="string">&quot;somewhere out there&quot;</span>,
        phone: ExternalPhoneNumber {
            main: <span class="number">1234</span>,
        },
    }
};

<span class="macro">assert_eq!</span>(external_user, expected_external_user);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23%5Bmacro_use%5D%20extern%20crate%20frunk%3B%0A%23%5Bmacro_use%5D%20extern%20crate%20frunk_core%3B%0Afn%20main()%20%7B%0Ause%20frunk%3A%3Alabelled%3A%3ATransmogrifier%3B%0A%0A%23%5Bderive(LabelledGeneric)%5D%0Astruct%20InternalPhoneNumber%20%7B%0A%20%20%20%20emergency%3A%20Option%3Cusize%3E%2C%0A%20%20%20%20main%3A%20usize%2C%0A%20%20%20%20secondary%3A%20Option%3Cusize%3E%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric)%5D%0Astruct%20InternalAddress%3C'a%3E%20%7B%0A%20%20%20%20is_whitelisted%3A%20bool%2C%0A%20%20%20%20name%3A%20%26'a%20str%2C%0A%20%20%20%20phone%3A%20InternalPhoneNumber%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric)%5D%0Astruct%20InternalUser%3C'a%3E%20%7B%0A%20%20%20%20name%3A%20%26'a%20str%2C%0A%20%20%20%20age%3A%20usize%2C%0A%20%20%20%20address%3A%20InternalAddress%3C'a%3E%2C%0A%20%20%20%20is_banned%3A%20bool%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric%2C%20PartialEq%2C%20Debug)%5D%0Astruct%20ExternalPhoneNumber%20%7B%0A%20%20%20%20main%3A%20usize%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric%2C%20PartialEq%2C%20Debug)%5D%0Astruct%20ExternalAddress%3C'a%3E%20%7B%0A%20%20%20%20name%3A%20%26'a%20str%2C%0A%20%20%20%20phone%3A%20ExternalPhoneNumber%2C%0A%7D%0A%0A%23%5Bderive(LabelledGeneric%2C%20PartialEq%2C%20Debug)%5D%0Astruct%20ExternalUser%3C'a%3E%20%7B%0A%20%20%20%20age%3A%20usize%2C%0A%20%20%20%20address%3A%20ExternalAddress%3C'a%3E%2C%0A%20%20%20%20name%3A%20%26'a%20str%2C%0A%7D%0A%0Alet%20internal_user%20%3D%20InternalUser%20%7B%0A%20%20%20%20name%3A%20%22John%22%2C%0A%20%20%20%20age%3A%2010%2C%0A%20%20%20%20address%3A%20InternalAddress%20%7B%0A%20%20%20%20%20%20%20%20is_whitelisted%3A%20true%2C%0A%20%20%20%20%20%20%20%20name%3A%20%22somewhere%20out%20there%22%2C%0A%20%20%20%20%20%20%20%20phone%3A%20InternalPhoneNumber%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20main%3A%201234%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20secondary%3A%20None%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20emergency%3A%20Some(5678)%2C%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D%2C%0A%20%20%20%20is_banned%3A%20true%2C%0A%7D%3B%0A%0A%2F%2F%2F%20Boilerplate-free%20conversion%20of%20a%20top-level%20InternalUser%20into%20an%0A%2F%2F%2F%20ExternalUser%2C%20taking%20care%20of%20subfield%20conversions%20as%20well.%0Alet%20external_user%3A%20ExternalUser%20%3D%20internal_user.transmogrify()%3B%0A%0Alet%20expected_external_user%20%3D%20ExternalUser%20%7B%0A%20%20%20%20name%3A%20%22John%22%2C%0A%20%20%20%20age%3A%2010%2C%0A%20%20%20%20address%3A%20ExternalAddress%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20%22somewhere%20out%20there%22%2C%0A%20%20%20%20%20%20%20%20phone%3A%20ExternalPhoneNumber%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20main%3A%201234%2C%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%7D%0A%7D%3B%0A%0Aassert_eq!(external_user%2C%20expected_external_user)%3B%0A%7D&amp;edition=2015">Run</a></div>
<p>Links:</p>
<ol>
<li><a href="https://github.com/lloydmeta/frunk">Source on Github</a></li>
<li><a href="https://crates.io/crates/frunk">Crates.io page</a></li>
</ol>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.lift_from"><code>pub use hlist::<a class="fn" href="hlist/fn.lift_from.html" title="fn frunk::hlist::lift_from">lift_from</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.HCons"><code>pub use hlist::<a class="struct" href="hlist/struct.HCons.html" title="struct frunk::hlist::HCons">HCons</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.HNil"><code>pub use hlist::<a class="struct" href="hlist/struct.HNil.html" title="struct frunk::hlist::HNil">HNil</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Func"><code>pub use traits::<a class="trait" href="traits/trait.Func.html" title="trait frunk::traits::Func">Func</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Poly"><code>pub use traits::<a class="struct" href="traits/struct.Poly.html" title="struct frunk::traits::Poly">Poly</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.ToMut"><code>pub use traits::<a class="trait" href="traits/trait.ToMut.html" title="trait frunk::traits::ToMut">ToMut</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.ToRef"><code>pub use traits::<a class="trait" href="traits/trait.ToRef.html" title="trait frunk::traits::ToRef">ToRef</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Coproduct"><code>pub use coproduct::<a class="enum" href="coproduct/enum.Coproduct.html" title="enum frunk::coproduct::Coproduct">Coproduct</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.convert_from"><code>pub use generic::<a class="fn" href="generic/fn.convert_from.html" title="fn frunk::generic::convert_from">convert_from</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.from_generic"><code>pub use generic::<a class="fn" href="generic/fn.from_generic.html" title="fn frunk::generic::from_generic">from_generic</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.into_generic"><code>pub use generic::<a class="fn" href="generic/fn.into_generic.html" title="fn frunk::generic::into_generic">into_generic</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.map_inter"><code>pub use generic::<a class="fn" href="generic/fn.map_inter.html" title="fn frunk::generic::map_inter">map_inter</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.map_repr"><code>pub use generic::<a class="fn" href="generic/fn.map_repr.html" title="fn frunk::generic::map_repr">map_repr</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Generic"><code>pub use generic::<a class="trait" href="generic/trait.Generic.html" title="trait frunk::generic::Generic">Generic</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.from_labelled_generic"><code>pub use labelled::<a class="fn" href="labelled/fn.from_labelled_generic.html" title="fn frunk::labelled::from_labelled_generic">from_labelled_generic</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.into_labelled_generic"><code>pub use labelled::<a class="fn" href="labelled/fn.into_labelled_generic.html" title="fn frunk::labelled::into_labelled_generic">into_labelled_generic</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.labelled_convert_from"><code>pub use labelled::<a class="fn" href="labelled/fn.labelled_convert_from.html" title="fn frunk::labelled::labelled_convert_from">labelled_convert_from</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.transform_from"><code>pub use labelled::<a class="fn" href="labelled/fn.transform_from.html" title="fn frunk::labelled::transform_from">transform_from</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.LabelledGeneric"><code>pub use labelled::<a class="trait" href="labelled/trait.LabelledGeneric.html" title="trait frunk::labelled::LabelledGeneric">LabelledGeneric</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Semigroup"><code>pub use semigroup::<a class="trait" href="semigroup/trait.Semigroup.html" title="trait frunk::semigroup::Semigroup">Semigroup</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Monoid"><code>pub use monoid::<a class="trait" href="monoid/trait.Monoid.html" title="trait frunk::monoid::Monoid">Monoid</a>;</code></div></div><div class="item-row"><div class="item-left import-item" id="reexport.Validated"><code>pub use validated::<a class="enum" href="validated/enum.Validated.html" title="enum frunk::validated::Validated">Validated</a>;</code></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="coproduct/index.html" title="frunk::coproduct mod">coproduct</a></div><div class="item-right docblock-short">Module that holds Coproduct data structures, traits, and implementations</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="generic/index.html" title="frunk::generic mod">generic</a></div><div class="item-right docblock-short">This module holds the machinery behind <code>Generic</code>.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="hlist/index.html" title="frunk::hlist mod">hlist</a></div><div class="item-right docblock-short">Module that holds HList data structures, implementations, and typeclasses.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="indices/index.html" title="frunk::indices mod">indices</a></div><div class="item-right docblock-short">Types used for indexing into HLists and coproducts.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="labelled/index.html" title="frunk::labelled mod">labelled</a></div><div class="item-right docblock-short">This module holds the machinery behind LabelledGeneric.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="monoid/index.html" title="frunk::monoid mod">monoid</a></div><div class="item-right docblock-short">Module for holding Monoid typeclass definitions and default implementations</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="path/index.html" title="frunk::path mod">path</a></div><div class="item-right docblock-short">Holds models, traits, and logic for generic traversal of models</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="frunk::prelude mod">prelude</a></div><div class="item-right docblock-short">Traits that need to be imported for the complete <code>frunk</code> experience.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="semigroup/index.html" title="frunk::semigroup mod">semigroup</a></div><div class="item-right docblock-short">Module for holding the Semigroup typeclass definition and typeclass instances</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="traits/index.html" title="frunk::traits mod">traits</a></div><div class="item-right docblock-short">Traits that provide generic functionality for multiple types in frunk</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="validated/index.html" title="frunk::validated mod">validated</a></div><div class="item-right docblock-short">Module for holding Validated logic</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.Coprod.html" title="frunk::Coprod macro">Coprod</a></div><div class="item-right docblock-short">Returns a type signature for a Coproduct of the provided types</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.HList.html" title="frunk::HList macro">HList</a></div><div class="item-right docblock-short">Returns a type signature for an HList of the provided types</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.field.html" title="frunk::field macro">field</a></div><div class="item-right docblock-short">Used for creating a Field</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.hlist.html" title="frunk::hlist macro">hlist</a></div><div class="item-right docblock-short">Returns an <code>HList</code> based on the values passed in.</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.hlist_pat.html" title="frunk::hlist_pat macro">hlist_pat</a></div><div class="item-right docblock-short">Macro for pattern-matching on HLists.</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.poly_fn.html" title="frunk::poly_fn macro">poly_fn</a></div><div class="item-right docblock-short">Returns a polymorphic function for use with mapping/folding heterogeneous
types.</div></div></div><h2 id="derives" class="small-section-header"><a href="#derives">Derive Macros</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.Generic.html" title="frunk::Generic derive">Generic</a></div><div class="item-right docblock-short">Derives a Generic instance based on HList for
a given Struct or Tuple Struct</div></div><div class="item-row"><div class="item-left module-item"><a class="derive" href="derive.LabelledGeneric.html" title="frunk::LabelledGeneric derive">LabelledGeneric</a></div><div class="item-right docblock-short">Derives a Generic instance based on Field + HList for
a given Struct (Tuple Structs not supported because they have
no labels)</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="frunk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0 (2c8cc3432 2023-03-06)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>